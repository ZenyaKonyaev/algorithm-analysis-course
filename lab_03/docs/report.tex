\documentclass[12pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
%\usepackage[14pt]{extsizes}
\usepackage{listings}
\usepackage{graphicx}
\usepackage{amsmath,amsfonts,amssymb,amsthm,mathtools} 
\usepackage{pgfplots}
\usepackage{filecontents}
\usepackage{indentfirst}
\usepackage{eucal}
\usepackage{amsmath}
\usepackage{enumitem}
\usepackage{fixltx2e}
\usepackage{float}

\frenchspacing

\usepackage{indentfirst} % Красная строка


%\usetikzlibrary{datavisualization}
%\usetikzlibrary{datavisualization.formats.functions}

\usepackage{amsmath}


% Для листинга кода:
\lstset{ %
language=caml,                 % выбор языка для подсветки (здесь это С)
basicstyle=\small\sffamily, % размер и начертание шрифта для подсветки кода
numbers=left,               % где поставить нумерацию строк (слева\справа)
numberstyle=\tiny,           % размер шрифта для номеров строк
stepnumber=1,                   % размер шага между двумя номерами строк
numbersep=5pt,                % как далеко отстоят номера строк от подсвечиваемого кода
showspaces=false,            % показывать или нет пробелы специальными отступами
showstringspaces=false,      % показывать или нет пробелы в строках
showtabs=false,             % показывать или нет табуляцию в строках
frame=single,              % рисовать рамку вокруг кода
tabsize=2,                 % размер табуляции по умолчанию равен 2 пробелам
captionpos=t,              % позиция заголовка вверху [t] или внизу [b] 
breaklines=true,           % автоматически переносить строки (да\нет)
breakatwhitespace=false, % переносить строки только если есть пробел
escapeinside={\#*}{*)}   % если нужно добавить комментарии в коде
}

\usepackage[left=2cm,right=2cm, top=2cm,bottom=2cm,bindingoffset=0cm]{geometry}


% plot
\usepackage{pgfplots}
\usepackage{filecontents}
\usetikzlibrary{datavisualization}
\usetikzlibrary{datavisualization.formats.functions}

\graphicspath{ {img/} }




\begin{document}
	\begin{titlepage}
		\thispagestyle{empty}
		
		\noindent
		\begin{minipage}{0.15\textwidth}
			\includegraphics[width=\linewidth]{main_logo}
		\end{minipage}
		\noindent
		\begin{minipage}{0.9\textwidth}
			\centering
			\textbf{Министерство науки и высшего образования Российской Федерации}\\
			\textbf{Федеральное государственное бюджетное образовательное учреждение высшего образования}\\
			\textbf{«Московский государственный технический университет имени Н.Э.~Баумана}\\
			\textbf{(национальный исследовательский университет)»}\\
			\textbf{(МГТУ им. Н.Э.~Баумана)}
		\end{minipage}
		
		\noindent
		\rule{18cm}{3pt} %пустая строка
		\newline\newline %пустая строка
		\noindent ФАКУЛЬТЕТ $\underline{\text{«Информатика и системы управления»}}$ \newline\newline
		\noindent КАФЕДРА $\underline{\text{«Программное обеспечение ЭВМ и информационные технологии»}}$\newline\newline\newline\newline\newline
		
		
		\begin{center}
			\noindent\begin{minipage}{1.3\textwidth}\centering
				\Large\textbf{  Отчёт о лабораторной работе №3}\newline
				\textbf{по дисциплине "Анализ алгоритмов"}\newline
				\textbf{на тему "Алгоритмы сортировки"}\newline\newline
			\end{minipage}
		\end{center}
		
		\noindent\textbf{Студент} $\underline{\text{Коняев Е.А}}$\newline\newline
		\noindent\textbf{Группа} $\underline{\text{ИУ7-53Б}}$\newline\newline
		\noindent\textbf{Преподаватели} $\underline{\text{Волкова Л.Л., Строганов Ю.В.}}$\newline\newline
		\noindent\textbf{Дата сдачи отчета}$\underline{\text{~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline
		\noindent\textbf{Оценка (баллы)} $\underline{\text{~~~~~~~~~~~~~~~~~~~~~~~~~~~}}$\newline\newline\newline
		
		\begin{center}
			\vfill
			Москва~---~\the\year~г.
		\end{center}
	\end{titlepage}
	
	\setcounter{page}{2}
	\tableofcontents
	
	\newpage
	\chapter*{Введение}
	
	\addcontentsline{toc}{chapter}{Введение}
	
	
Алгоритмы сортировки — это набор инструкций, которые принимают массив или список в качестве входных данных и упорядочивают элементы в определенном порядке. Сортировка чаще всего осуществляется в числовом или алфавитном (или лексикографическом) порядке и может быть в порядке возрастания (A-Z, 0-9) или убывания (Z-A, 9-0).

Сортировки важны потому что они часто могут уменьшить сложность решаемой задачи, а потому алгоритмы сортировки очень важны в компьютерных науках. Эти алгоритмы имеют прямое применение в алгоритмах поиска, алгоритмах баз данных, методах разделяй и властвуй, алгоритмах структуры данных и многом другом.\newline\newline
При выборе алгоритма сортировки необходимо учитывать: 
\begin{enumerate}
	\item количиество сортируемых элементов;
	\item количество доступной памяти;
	\item возможность увеличения коллекции с сортируемыми элементами.
\end{enumerate}
  

Эти факторы могут определить, какой алгоритм будет работать лучше всего в каждой ситуации. Некоторым алгоритмам может потребоваться много места или памяти для запуска, в то время как другим, при том, что они не являются самыми быстрыми, не требуется много ресурсов для запуска.

Именно из-за разнообразия алгоритмов сортровок, их особенностей и областей применения, данная работа была посвещена анализу некоторых из этих алгоритмов.
	
	
	

	
	\chapter{Аналитическая часть}
	
	\section{Цели и задачи}
	
	Целью данной работой является исследования алгоритмов сортировок пузырьком, вставками и выбором. Для этого в ходе исследования алгоритмов требуется решить следующие задачи:
	\begin{enumerate}
		\item изучить и рассмотреть выбранный алгоритмы сортировок;
		\item построить блок-схемы выбранных алгоритмов;
		\item реализовать каждый из алгоритмов;
		\item рассчитать их трудоемкость;
		\item эксперитментально оценить временные характеристики алгоритмов;
		\item сделать вывод на основании проделанной работы.
	\end{enumerate}
	
	
	\section{Сортировка расческой}
	
	 Сортировка расческой (на анг. Comb sort) является улучшенным вариантом сортировки пузырьком. В сортировке пузырьком сравнениваются и перестановляются соседние элементы, то есть разница индексов этих элементов всегда 1. В соритровке же рассческой это расстояние увеличено и сравниваются элементы стоящие на большем расстоянии друг от друга. С очередным проходом это расстояние уменьшается. Таким образом, максимальные элементы, находящиеся в начале массива, можно поместить в его конец за меньшее количество перестановок (в сортировке по возрастанию). 
	 
	 Число, на которое должен раз за разом уменьшаться разрыв называется фактором уменьшения и равно 1.247 (выведено авторами сортировки). После каждой итерации расстояние между элементами делится на фактор, округляется, и так продолжается, пока оно не станет равным 1.
	
	\section{Карманная сортировка}
	
	Карманная (блочная, корзинная) сортировка  — это сортировка, в ходе которой элементы, которые необходимо отсортировать, распределяются между конечным числом отдельных блоков (карманов) так, чтобы все элементы в каждом следующем по порядку блоке были всегда больше (или меньше, в зависимости от возрастания/убывания), чем в предыдущем. После этого каждый блок сортируется отдельно с помощью какого-либо алгоритма сортировки, либо соритруется рекурсивно карманной сортировкой. После этого элементы из полученных блоков по порядку помещаются обратно в массив, в результате чего получается отсоритрованные по возрастанию/убыванию входные данные.

	
	\section{Битонная сортировка}
	
	Битонная сортировка — это алгоритм сортировки, который часто используется в параллельных сортировках, так элементы сравниваются в предопределенной последовательности, которая не зависит от входных данных. Эта предопределенная последовательность называется битонной последовательностью. Битонная последовательность - это последовательность, в которой элементы сначала неубывают, а потом с определенного элемента невозрастают.
	
	На первом этапе соритровки необходимо создать битонную последовательность из заданной случайной последовательности сортируемых элементов (например, отсортировать элементы по возрастанию, а затем, начиная с середины последовательности, развернуть элементы в обратном порядке). Далее необходимо поменять местами элементы между двумя половинами последовательности, если какой-либо элемент во второй половине окажется меньше. Таким образом мы получили все элементы в первой половине меньше, чем все элементы во второй половине. Результаты сравнения и обмена в две последовательности длиной $N/2$ каждая, где N - кол-во элементов в последовательности. Далее необходимо повторять процесс обмена рекурсивно для каждой половины последовательности пока не получим одну отсортированную последовательность длины $N$.
	
	\section{Вывод}
	
	В данном разделе были рассмотрены 3 алгоритма сортировки: расческой, карманная и битонная.
	
	\clearpage
	
	\chapter{Конструкторская часть}
	
	\section{Модель вычислений}

	Для вычисления трудоемкости будем использовать следующую модель вычислений:

	\begin{enumerate}
		\item Операции из списка (\ref{for:opers}) имеют трудоемкость 1.
		\begin{equation}
		\label{for:opers}
		+, -, /, \%, ==, !=, <, >, <=, >=, [], ++, {-}-
		\end{equation}
		\item Трудоемкость оператора выбора if условие then A else B рассчитывается, как (\ref{for:if}).
		\begin{equation}
		\label{for:if}
		f_{if} = f_{\text{условия}} +
		\begin{cases}
		f_A, & \text{условие выполняется,}\\
		f_B, & \text{иначе.}
		\end{cases}
		\end{equation}
		\item Трудоемкость вызова функции равна 0.
		\item Трудоемкость цикла рассчитывается, как (\ref{for:for}).
		\begin{equation}
		\label{for:for}
		f_{for} = f_{\text{инициализации}} + f_{\text{сравнения}} + N(f_{\text{тела}} + f_{\text{инкремента}} + f_{\text{сравнения}})
		\end{equation}
	\end{enumerate}
	
	\section{Трудоёмкость алгоритмов}

	Размер массива во всех вычислениях обозначим как $N$.

	\subsection{Алгоритм сортировки расческой}

	Обозначим расстояние между просматриваемыми элементами как $gap$. Алгоритм перебирает элементы от 0 до $N-gap$ на каждом шаге. Обозначим кол-во перебираемых элементов на $i$-м шаге внешнего цикла как $N_{i}$. Тогда:
	
	\begin{equation}
	\label{for:count_ni}
	N_{i} = N - floor(\frac{gap_{i}}{1.247})
	\end{equation}
	
	
	$gap_{i}$ на $i$-м шаге вычисляется как:
	
	
	\begin{equation}
	\label{for:count_gapi}
	gap_{i} = gap_{i-1} - floor(\frac{gap_{i-1}}{1.247})
	\end{equation}
	
	В \textbf{худшем} случае все элементы отсортированы в обратном порядке. Вычисляя верхнюю границу $N_{i}$ из уравнения (\ref{for:count_ni}) и рекуррентного соотношения (\ref{for:count_gapi}) для наихудшего случая, мы получаем выражение, содержащее члены второй и первой степени $N$ с константой, дающей верхнюю границу $N^2$. Таким образом, временная сложность наихудшего случая равна $O(N^2)$
	
	\textbf{Лучший} случай возникает, когда все элементы уже отсортированы . В этом случае цикл с $gap=1$ будет запущен только один раз (как и остальные). Тогда кол-во проходов внутреннего цикла, на $i$-й итерации можно выразить формулой:
	
	\begin{equation}
	N_{i}=\frac{N}{1.247^{i}}
	\end{equation}
	
	А кол-во всех проходов выражается как:

	\begin{equation}
	\label{for:count_worst_comb}
	S_{N}=N\sum_{r=1}^{n} \frac{1}{1.247^r}
	\end{equation}
	
	Выражение под знаком суммы в формуле (\ref{for:count_worst_comb}) приблизительно равняется $O(log(N))$. Тогда вся сумма будет равнятся $O(Nlog(N)$, что будет являться сложностью алгоритма в лучшем случае.
	
	\subsection{Алгоритм карманной сортировки}
	
	Обозначим кол-во карманов за $k$. Алгоритм состоит из 4-х последовательно идущих циклов: 
	\begin{enumerate}
		\item поиска минимума и максимума среди всех элементов массива;
		\item распределения элементов массива по соответсвтующим корзинам;
		\item сортироки элементов каждой корзины другим алгоритмом сортировки;
		\item соединения всех корзин воедино.
	\end{enumerate}
	
	Цикл поиска максимума и минимума среди всех элементов работает за:
	\begin{equation}
		f_{1} = 1 + 1 + N\cdot(2 * 3 + 1 + 1) = 2 + 8N = O(N)
	\end{equation}
	
	Цикл распределения элементов массива по соответсвтующим корзинам работает за:
	\begin{equation}
		f_{2} = 1 + 1 + N\cdot(12 + 1 + 1) = 2 + 14N = O(N)
	\end{equation}
	
	Цикл сортироки элементов каждой корзины другим алгоритмом сортировки работает за:
	\begin{enumerate}
		\item В \textbf{лучшем} случае (элементы распределены по корзинам равномерно $O(k)$, входной массив расположен так, что внутренняя сортировка работает за лучшее время $O(N)$):
		\begin{equation}
		f_{3} = O(N + k)
		\end{equation}
		\item В \textbf{худшем} случае (элементы не имеют математической разницы между собой и внутренняя сортировка работает за худшее время $O(N^2)$):
		\begin{equation}
		f_{3} = O(N^2)
		\end{equation}
	\end{enumerate}
	
	Так как все $N$ элементов расспределены равномерно по $k$ корзинам, то цикл соединения всех корзин воедино работает за:
	\begin{equation}
		f_{4} = O(N + k)
	\end{equation}
	
	Итоговая сложность алгоритма будет вычисляться как $f = f_{1} + f_{2} + f_{3} + f_{4}$. В \textbf{худшем} случае эта сложность равна $O(N^2)$, а в \textbf{лучшем} $O(N + k)$
	
	\subsection{Алгоритм битонной сортировки}
	
	Исходя из источников литературы сложность алгоритма битонной сортировки как в \textbf{лучшем}, так и в \textbf{худшем} случае равна $O(log^{2}(N)$.
	
	\section{Схемы алгоритмов}
	
	
	На рисунках ниже показаны схемы алгоритмов карманной сортировки, расческой и битонной соответственно.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.3\linewidth]{bucket_1}
		\caption{Схема карманной сортировки ч.1}
		\label{fig:schema_bucket_1}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\linewidth]{bucket_2}
		\caption{Схема карманной сортировки ч.2}
		\label{fig:schema_bucket_2}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics{bucket_3}
		\caption{Схема карманной сортировки ч.3}
		\label{fig:schema_bucket_3}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.5\linewidth]{combSort_1}
		\caption{Схема сортировки расческой ч.1}
		\label{fig:schema_selection}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics{combSort_2}
		\caption{Схема сортировки расческой ч.2}
		\label{fig:schema_selection}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics{bitonic_1}
		\caption{Схема основной функции алгоритма битонной сортировки}
		\label{fig:schema_insertion}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.9\linewidth]{bitonic_2}
		\caption{Схема процедуры bitSortRec алгоритма битонной сортировки}
		\label{fig:schema_insertion}
	\end{figure}
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.7\linewidth]{bitonic_3}
		\caption{Схема процедуры bitConnect алгоритма битонной сортировки}
		\label{fig:schema_insertion}
	\end{figure}
	
	\section{Вывод}
	
	В данном разделе на основе теоретических данных, полученных в аналитическом разделе были разработаны схемы алгоримов трех рассматриваемых алгоритмов сортировок.
	
	\chapter{Технологическая часть}
	
	В данном разделе преведены требования к ПО, обоснования выбора языка программирования, среды разработки, приведен способ замера времени выполнения, а так же приведены листинги кода.
	
	\section{Требования к ПО}
	
	В программе должна присутсвовать возможность :
	
	\begin{enumerate}
		\item указания размера входного массива, а так же его элементов;
		\item сортировки входного массива одним из трех рассматриваемых способов сортировок;
		\item проверки временных характеристик на разных типах входных массивов (упорядочен по возрастанию/убыванию, заполнен случайными числами), для рассматриваемых способов сортировок.
	\end{enumerate}
	
	\section{Выбор языка программирования и среды разработки}
	
	Для реализации трех алгоритмов сортировок был выбор язык С, так как я уже знаком с данным языком и поставленная задача будет решена максимально быстро.

	Средой разработки был выбран СLion. Данный выбор обусловлен тем, что данная среда на сегодняшний момент является по-моему мнению самой удобной IDE для разработки под C/C++, в силу того, что предоставляет мощные инструменты для отладки кода и его быстрого написания. 
	
	\section{Выбор библиотеки и способа для замера времени}
		Для замера времени выполнения сортировок использовалась стандартная функция библиотеки <time.h> языка С~---~clock(), которая замеряет процессорное время. Если измерить время перед началом выполнения алгоритма, и после его окончания, то можно получить время выполнения функции. Реализация данной функции привидена в списке литературы[1].
		
		Посколько все процессорное время не отдается какоЙ-либо одной задаче (явление вытеснения процессов из ядра, квантование процессорного времени), то усреднить результаты вычислений: замерить совокупное время выполнения реализации алгоритма N раз и вычислить среднее время выполнения.
		
	\section{Листинги кода}
	
	В листингах \ref{bubble-code},\ref{selection-code},\ref{insertion-code} приведены листинги алгоритмов карманной, битонной сортировок и сортировки расческой  соответсвенно.
	
	\begin{lstlisting}[label=bubble-code,caption=Листинг карманной сортировки,language=C]
		void pushBackBucket(bucket *b, sortElem *e)
		{
		    b->arr[b->len] = *e;
		    (b->len)++;
		}

		void bucketSort(sortElem *arr, size_t n)
		{
		    if (n < 2)
			return clock() - timeStart;

		    sortElem min = { INF, DEFAULT_C, DEFAULT_D };
		    sortElem max = { -INF, DEFAULT_C, DEFAULT_D };
		    for (size_t i = 0; i < n; ++i) {
			if (comparatorIncrease(&max, arr + i))
			    max = arr[i];
			if (comparatorIncrease(arr + i, &min))
			    min = arr[i];
		    }

		    double range = (max.val) - min.val;
		    double lengthBucket = range / nBus;

		    for (size_t i = 0; i < n; ++i) {
			size_t idxBucket = (int)((arr[i].val - min.val) / lengthBucket);
			idxBucket = idxBucket >= nBus ? idxBucket - 1 : idxBucket;
			pushBackBucket(arrB + idxBucket, arr + i);
		    }

		    for (size_t i = 0; i < nBus; ++i)
			qsort(arrB[i].arr, arrB[i].len, sizeof(sortElem), comparatorIncrease);

		    size_t idx = 0;
		    for (size_t i = 0; i < nBus; ++i)
			for (size_t j = 0; j < arrB[i].len; ++j)
			    arr[idx++] = arrB[i].arr[j];
		}
	\end{lstlisting}

	
	\begin{lstlisting}[label=selection-code,caption=Листинг битонной сортировки,language=C]
		void compare(sortElem *arr, size_t i, size_t j, int d)
		{
		    if (d == comparatorIncrease(arr + i , arr + j))
		    {
			sortElem tmp = arr[i];
			arr[i] = arr[j];
			arr[j] = tmp;
		    }
		}

		void bitonicConnect(sortElem* arr, size_t lo, size_t n, int d)
		{
		    if (n < 2)
			return;

		    size_t m = n / 2;
		    for (size_t i = lo; i < lo + m; ++i)
		    {
			compare(arr, i, i + m, d);
		    }
		    bitonicConnect(arr, lo, m, d);
		    bitonicConnect(arr, lo + m, m, d);
		}

		void bitonicSortRecursive(sortElem *arr, size_t lo, size_t n, int dir)
		{
		    if (n < 2)
			return;

		    size_t m = n / 2;
		    bitonicSortRecursive(arr, lo, m, INC);
		    bitonicSortRecursive(arr, lo + m, m, DEC);
		    bitonicConnect(arr,lo, n, dir);
		}

		void bitonicSort(sortElem *arr, size_t n)
		{
		    bitonicSortRecursive(arr, 0, n, INC);
		}
	\end{lstlisting}
	
	\bigbreak

	\begin{lstlisting}[label=insertion-code,caption=Листинг сортировки расческой,language=C]
		void combSort(sortElem *arr, size_t n)
		{
		    float factor = 1.247f;
		    size_t gap = (size_t)(n / factor);
		    int swapped = 1;
		    while (gap != 1 || swapped) {
			swapped = 0;
			for(size_t i = 0, j = gap; j < n; ++i, ++j)
			{
			    if (comparatorIncrease(arr + i, arr + j)) {
				sortElem tmp = arr[i];
				arr[i] = arr[j];
				arr[j] = tmp;
				swapped = 1;
			    }
			}
			gap = gap / factor < 1 ? 1 : gap / factor;
		    }
		}
	\end{lstlisting}

	\section{Тестирование алгоритмов}

	В таблице~\ref{tbl:test} приведены тесты для функций, реализующих алгоритмы сортировки. Все тесты пройдены успешно.
	
	\begin{table}[h!]
		\begin{center}
			\begin{tabular}{|c|c|c|}
				\hline
				Входной массив & Результат & Ожидаемый результат \\ 
				\hline
				$[10, 20, 30, 40, 50]$ & $[10, 20, 30, 40, 50]$  & $[10, 20, 30, 40, 50]$\\\hline
				$[50, 40, 30, 20, 10]$  & $[10, 20, 30, 40, 50]$ & $[10, 20, 30, 40, 50]$\\\hline
				$[-15, -21, -37, -24, -54]$  & $[-54, -37, -24, -21, -15]$  & $[-54, -37, -24, -21, -15]$\\\hline
				$[4]$  & $[4]$  & $[4]$\\\hline
				Пустой массив  & Пустой массив  & Пустой массив\\
				\hline
			\end{tabular}
			\caption{\label{tbl:test}Тестирование функций}
		\end{center}
	\end{table}

	\section{Вывод}
	
	В данном разделе были разработаны исходные коды трёх алгоритмов сортировок: расческой, битонной и карманной.
	
	\chapter{Экспериментальная часть}
	
	\section{Технические характеристики}
	
	Ниже приведены технические характеристики устройства, на котором было проведено тестирование ПО:
	
	\begin{enumerate}
		\item Операционная система: Windows-10, 64-bit;
		\item Оперативная память: 16 GB;
		\item Процессор: Intel(R) Core(TM) i7-8565U CPU @ 1.80GHz, 1992 МГц, 4 ядра, 8 логических процессоров.
		
		
	\end{enumerate}
	
	\section{Время выполнения алгоритмов}
	
	\begin{table} [h!]
		\caption{Таблица времени выполнения сортировок на данных, отсоритрованных по возрастанию (в мс)}
		\begin{center}
			\begin{tabular}{|c | c | c | c|}
				
				\hline
				
				Размер & comb & bucket & bitonic  \\ [0.5ex]
				
				\hline
				
				100 & 7.8 & 7.61 & 27.3 \\ 
				
				\hline 
				
				1000 & 113 & 100.4 & 428.1 \\ 
				
				\hline 
				
				10000 & 1750 & 801.57 & 12427.6 \\ 
				
				\hline 
			\end{tabular}
		\end{center}
	\end{table}

	\begin{center}
		\begin{tikzpicture}
				\begin{axis} [
					legend pos = north west,
					grid = major,
					xmin = 0,
					ymin = 0, 
					xmax = 10000,
					ymax = 13000,
					xlabel = $\text{кол-во элементов}$,
					ylabel = $\text{время (мс)}$,
					title=$\text{График зависимости времени сортировок от кол-ва элементов на упорядоченном массиве}$
					]
					\legend{ 
						$comb$, 
						$bucket$, 
						$bitonic$
					};
					\addplot coordinates {
						(100,7.08) (1000,113) (10000,1750)
					};
					\addplot coordinates {
						(100,7.61) (1000,100.4) (10000,801.57)
					};
					\addplot coordinates {
						(100,27.3) (1000,428.1) (10000,12427.6)
					};
				\end{axis}
		\end{tikzpicture}
	\end{center}
	
	\begin{table} [h!]
		\caption{Таблица времени выполнения сортировок на данных, отсоритрованных по убыванию (в мс)}
		\begin{center}
			\begin{tabular}{|c | c | c | c|}
				
				\hline
				
				Размер & comb & bucket & bitonic  \\ [0.5ex]
				
				\hline
				
				100 & 9.6 & 7.71 & 28.49 \\ 
				
				\hline 
				
				1000 & 130.27 & 96.4 & 390.85 \\ 
				
				\hline 
				
				10000 & 2066.09 & 888.5 & 11475.05 \\ 
				
				\hline 
				
			\end{tabular}
		\end{center}
	\end{table}

	\begin{center}
		\begin{tikzpicture}
			\begin{axis} [
				legend pos = north west,
				grid = major,
				xmin = 0,
				ymin = 0, 
				xmax = 10000,
				ymax = 13000,
				xlabel = $\text{кол-во элементов}$,
				ylabel = $\text{время (мс)}$,
				title=$\text{График зависимости времени сортировок от кол-ва элементов на обратно упорядоченном массиве}$
				]
				\legend{ 
					$comb$, 
					$bucket$, 
					$bitonic$
				};
				\addplot coordinates {
					(100,9.6) (1000,130.27) (10000,2066.09)
				};
				\addplot coordinates {
					(100,7.71) (1000,96.4) (10000,888.5)
				};
				\addplot coordinates {
					(100,28.49) (1000,390.85) (10000,11475.05)
				};
			\end{axis}
		\end{tikzpicture}
	\end{center}
	
	\begin{table} [h!]
		\caption{Таблица времени выполнения сортировок на случайных данных (от 0 до 1000) (в мс)}
		\begin{center}
			\begin{tabular}{|c | c | c | c|}
				
				\hline
				
				Размер & comb & bucket & bitonic  \\ [0.5ex]
				
				\hline
				
				100 & 12.38 & 12.78 & 39.79 \\ 
				
				\hline 
				
				1000 & 189.44 & 189.77 & 486.02 \\ 
				
				\hline 
				
				10000 & 2491.19 & 1975.79 & 12273.07 \\ 
				
				\hline 
				
			\end{tabular}
		\end{center}
	\end{table}


	\begin{center}
		\begin{tikzpicture}
			\begin{axis} [
				legend pos = north west,
				grid = major,
				xmin = 0,
				ymin = 0, 
				xmax = 10000,
				ymax = 13000,
				xlabel = $\text{кол-во элементов}$,
				ylabel = $\text{время (мс)}$,
				title=$\text{График зависимости времени сортировок от кол-ва элементов на массиве случайных чисел}$
				]
				\legend{ 
					$comb$, 
					$bucket$, 
					$bitonic$
				};
				\addplot coordinates {
					(100,12.38) (1000,189.44) (10000,2491.19)
				};
				\addplot coordinates {
					(100,12.78) (1000,189.77) (10000,1975.79)
				};
				\addplot coordinates {
					(100,39.79) (1000,486.02) (10000,12273.07)
				};
			\end{axis}
		\end{tikzpicture}
	\end{center}
	
	\begin{table} [h!]
		\caption{Таблица времени выполнения сортировок на случайных данных (от 0 до 3) (в мс)}
		\begin{center}
			\begin{tabular}{|c | c | c | c|}
				
				\hline
				
				Размер & comb & bucket & bitonic  \\ [0.5ex]
				
				\hline
				
				100 & 8.89 & 8.08 & 31.94 \\ 
				
				\hline 
				
				1000 & 100.6 & 100.66 & 405.61 \\ 
				
				\hline 
				
				10000 & 1763.35 & 1286.04 & 11061.61 \\ 
				
				\hline 
				
			\end{tabular}
		\end{center}
	\end{table}
	
	\begin{center}
		\begin{tikzpicture}
			\begin{axis} [
				legend pos = north west,
				grid = major,
				xmin = 0,
				ymin = 0, 
				xmax = 10000,
				ymax = 13000,
				xlabel = $\text{кол-во элементов}$,
				ylabel = $\text{время (мс)}$,
				title=$\text{График зависимости времени сортировок от кол-ва элементов на массиве случайных чисел}$
				]
				\legend{ 
					$comb$, 
					$bucket$, 
					$bitonic$
				};
				\addplot coordinates {
					(100,8.89) (1000,100.6) (10000,1763.35)
				};
				\addplot coordinates {
					(100,8.08) (1000,100.66) (10000,1286.04)
				};
				\addplot coordinates {
					(100,31.94) (1000,405.61) (10000,11061.61)
				};
			\end{axis}
		\end{tikzpicture}
	\end{center}
	

	\section{Вывод}
	
	Алгоритм сортировки вставками работает лучше сортировок выбором и пуззырьком на случайных и уже отсортированных числах. Сортировка вставками массива из 10000 элементов в 3.3 раза быстрее сортировки пузырььком и в 1.6 раз ьыстрее сортировки выбором. Следовательно, алгоритм сортировки вставками работает быстрее, чем алгоритм сортировки пузырьком и выбором на больших массивах данных.
	
	\chapter*{Заключение}
	
	В рамках данной лабораторной работы:
	
	\begin{enumerate}
		\item были изучены и рассмотрены алгоритмы сортировок пузырьком, вставками и выбором;
		\item были построены блок-схемы выбранных алгоритмов;
		\item был реализован каждый из алгоритмов;
		\item была рассчитана их трудоемкость;
		\item были эксперитментально оценены временные характеристики алгоритмов;
		\item были сделаны выводы на основании проделанной работы
	\end{enumerate}
	
	На основании анализа трудоемкости алгоритмов в выбранной модели вычислений, было показано, что алгоритм сортировки вставками имеет наименьшую сложность в уже отсортированном массиве, а так же эффективнее работает на массиве размером 10000, обгоняя по скорости алгоритмы пузырьком и выбором.
	
%	\addcontentsline{toc}{chapter}{Литература}
	
%	\bibliographystyle{utf8gost705u}  % стилевой файл для оформления по ГОСТу
	
%	\bibliography{51-biblio}
	
\end{document}
